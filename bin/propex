#!/usr/bin/env python
from __future__ import print_function
import argparse
import itertools
import os
import sys

import propex

def get_probe(fname):
    with open(fname) as f:
        try:
            seqs = [propex.sequence.Sequence(line.strip()) for line in f \
                if len(line.strip()) > 0]
        except ValueError:
            print('ERROR: probe file does not contain valid sequences',
                file=sys.stderr)
            exit(1)

    if len(seqs) == 0:
        print('ERROR: probe file is empty', file=sys.stderr)
        exit(1)
    elif len(seqs) > 2:
        print('ERROR: probe file contains too many sequences', file=sys.stderr)

    return seqs

def get_single_sequence(fname, genbank_only=False, stop_on_error=False):
    seq = None
    genbank_success = False
    fasta_success = False
    try:
        seq = propex.GenBank(fname)
        genbank_success = True
    except ValueError:
        pass

    if not genbank_success and not genbank_only:
        try:
            seq = propex.Fasta(fname)
            fasta_success = True
        except ValueError:
            pass

    if not (genbank_success or fasta_success):
        if genbank_only:
            if stop_on_error:
                print('ERROR: file ignored. If you want to perform '
                    'operon extraction, you need annotations. Currently only '
                    'GenBank files are supported.', file=sys.stderr)
                sys.exit(1)
            print('ignored', file=sys.stderr)
            return 1
        else:
            if stop_on_error:
                print('ERROR: parsing failed', file=sys.stderr)
            print('parsing failed', file=sys.stderr)
            return -1
    else:
        print('{0} sequence{1}'.format(len(seq), 's' if len(seq) > 1 else ''),
            file=sys.stderr)
        return seq

def get_sequences(dirname, genbank_only=False):
    files = filter(os.path.isfile,
        [os.path.join(dirname, x) for x in os.listdir(dirname)])

    n_ignore = 0
    seqs = []

    print('Parsing sequence files', file=sys.stderr)

    for fname in files:
        print('\t{0}'.format(fname), file=sys.stderr, end='\t')
        parse_res = get_single_sequence(fname, genbank_only)
        if parse_res == -1:
            continue
        elif parse_res == 1:
            n_ignore += 1
        else:
            seqs.append(parse_res)

    if n_ignore > 0:
        print('WARNING: {0} file{1} ignored. If you want to perform '
            'operon extraction, you need annotations. Currently only '
            'GenBank files are supported.'.format(n_ignore,
            's' if n_ignore > 1 else ''), file=sys.stderr)
    if len(seqs) == 0:
        print('ERROR: no sequence files found', file=sys.stderr)
        exit(1)

    return seqs

def match_probe(probe, seqs, mismatches=2):
    matches = []
    pl = len(probe)
    for f in seqs:
        for record in f:
            res1 = propex.search.search(str(probe), str(record.seq),
                mismatches=mismatches)
            res2 = [len(record.seq) - x - pl for x in \
                propex.search.search(str(probe), str(record.seq.revcomp()),
                    mismatches=mismatches)]

            if len(res1) > 0:
                for start in res1:
                    hit_seq = record.seq[start:start + pl]
                    matches.append([
                        f.filename, record.name, start + 1,
                        start + pl, pl, hit_seq, '+'
                    ])

            if len(res2) > 0:
                for start in res2:
                    hit_seq = record.seq[start:start + pl]
                    matches.append([
                        f.filename, record.name, start + 1,
                        start + pl, pl, hit_seq, '-'
                    ])
    return matches


def match_primer(primers, seqs, mismatches=2):
    matches = []
    pl1 = len(primers[0])
    pl2 = len(primers[1])
    for f in seqs:
        for record in f:
            res1_1 = propex.search.search(str(primers[0]), str(record.seq),
                mismatches=mismatches)
            res1_2 = [len(record.seq) - x - pl1 for x in \
                propex.search.search(str(primers[0]), str(record.seq.revcomp()),
                    mismatches=mismatches)]

            res2_1 = propex.search.search(str(primers[1]), str(record.seq),
                mismatches=mismatches)
            res2_2 = [len(record.seq) - x - pl2 for x in \
                propex.search.search(str(primers[1]), str(record.seq.revcomp()),
                    mismatches=mismatches)]

            # Match res1_1 with res2_2 and res2_1 with res1_2 to get primer
            # pairs. The first position must be smaller than the second
            # position, and the product length must be within the allowed
            # range.

            if len(res1_1) > 0 and len(res2_2) > 0:
                # Match them
                for start, end in itertools.product(res1_1, res2_2):
                    if start >= end:
                        continue
                    product_length = end - start + pl2
                    hit_seq = record.seq[start:start + product_length]
                    matches.append([
                        f.filename, record.name, start + 1,
                        end + 1, product_length, hit_seq,
                        '+'
                    ])

            if len(res2_1) > 0 and len(res1_2) > 0:
                for start, end in itertools.product(res2_1, res1_2):
                    if start >= end:
                        continue
                    product_length = end - start + pl1
                    hit_seq = record.seq[start:start + product_length]
                    matches.append([
                        f.filename, record.name, start + 1,
                        end + 1, product_length, hit_seq,
                        '-'
                    ])
    return matches


def write_fasta(matches, filename=sys.stdout):
    for m in matches:
        s = propex.fasta.FastaRecord(m[5],
            '{fname}:{seqname}:{start}:{stop}:{length}'.format(fname=m[0],
                seqname=m[1], start=m[2], stop=m[3], length=m[4]))
        print(s, file=filename)


def parse_args():
    parser = argparse.ArgumentParser()

    parser.add_argument('genomedir', help=('directory containing the genome '
        'files to use (FASTA or GenBank format) or a single GenBank or '
        'FASTA file'))
    parser.add_argument('probe', help=('FASTA file containing either a '
        'single sequence (probe) or a pair of sequences (primer pair)'))

    parser.add_argument('--pcr', help='only perform in silico PCR',
        action='store_true')

    parser.add_argument('-m', '--mismatches', help=('the maximum number of '
        'mismatches allowed when aligning probe/primer to the genome'),
        type=int, default=2, metavar='N')

    parser.add_argument('--version', help=('print version and exit'),
        action='version', version='%(prog)s v{0}'.format(propex.__version__))

    args = parser.parse_args()

    args.genomedir = os.path.abspath(args.genomedir)
    args.probe = os.path.abspath(args.probe)

    # Check paths
    if not os.path.exists(args.genomedir):
        parser.error('file or directory not found: {}'.format(args.genomedir))
    args.isdir = os.path.isdir(args.genomedir)
    if not os.path.exists(args.probe):
        parser.error('file or directory not found: {}'.format(args.probe))

    # Mismatches should be an integer >= 0
    if args.mismatches < 0:
        parser.error('mismatches must not be negative')

    return args

def main():
    args = parse_args()

    probe = get_probe(args.probe)
    is_primer = len(probe) == 2

    if args.isdir:
        seqs = get_sequences(args.genomedir, genbank_only=not args.pcr)
    else:
        seqs = [get_single_sequence(args.genomedir, genbank_only=not args.pcr,
            stop_on_error=True)]

    if is_primer:
        matches = match_primer(probe, seqs, mismatches=args.mismatches)
    else:
        matches = match_probe(probe[0], seqs, mismatches=args.mismatches)

    if is_primer and args.pcr:
        write_fasta(matches)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('Keyboard interrupt', file=sys.stderr)
        exit(1)
